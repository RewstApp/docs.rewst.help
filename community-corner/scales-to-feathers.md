# Scales to Feathers
*Rewst resources for Dinosaurs who want to evolve into Chickens*
## Article 1: Rewst Basics
### Introduction
The Scales to Feathers documentation series is aimed at people with a background in programming that may feel dated in the world of modern web development.  If you’ve written lots of code for desktop apps or backend server procedures but have only dabbled in modern (Web 3.0+) web development, this series is for you.

The primary intent is to take the terms and concepts you are familiar with and map them to the equivalent code and concepts using Workflow Actions and Jinja templating.  If you’ve worked in everything from BASIC to C/C++ to .Net/Java (or any combination thereof) then this series is for you.
### Workflows (Briefly)
If you’ve made it to the point of reading this documentation, you’re probably already familiar with what Workflows are in Rewst and why you would want to use them.  But in case you’ve found this first, here are some general resources about what Workflows are in Rewst and why you’d want to use them.
- [TODO: Replace with valid link to ‘what is Rewst’ document]
- [TODO: Replace with valid link to general Workflow information]
- [TODO: etc]
### The Rewst Platform
This topic is worthy of its own article, with in-depth information about the platform architecture and workflow execution, but at a minimum it is important to understand that the Rewst Platform is leveraging a combination of parallel and asynchronous processing.  Individual actions may be executed in parallel but the statements within an action are often executed asynchronously.

Since asynchronous code executes in the backend of the platform, your workflow actions only have access to the asynchronous result after execution.  While we will touch on how this may impact your debugging experience later in the article, the important initial takeaway is that your code will always need to work with the awaited result, not the async operation itself.
### Data Format
As an automation solution for Web APIs it should be no surprise that the data format for almost everything in the Rewst platform is JSON.  Hopefully JSON is one of the bits of Web 3.0 that you are already familiar with as it has replaced XML as the most common open data interchange format, and you’ve probably used it for something by this point.  If not, visit https://www.json.org/ for all the detail – it is a relatively simple and straightforward data format.
### Context
The Context in a Rewst Workflow is very much the same as the concept of contexts in any other platform – it is a place for all data relating to a current process to live in isolation from data belonging to other unrelated processes.

In Rewst, the context is a JSON object containing attributes that hold meta data about the workflow along with all of the context data generated by the workflow execution.  The contents of this object are continually appended to as the workflow executes.  Each of the context object’s attributes are exposed to the code of the workflow through the CTX identifier.

Accessing the members of CTX is the primary way to pass data between actions within a workflow, and between the input/output variables of other workflows.
### Workflows, Integrations and Actions
A Workflow in Rewst is like a program or module in other platforms.  The Workflow is the primary output of your development and can be thought of a little like compiling your program into a DLL (albeit an assembly with a single object).  The workflow itself has no actual interface or output view, but it can be referenced sort of like an object in an external assembly and be passed input data and have its output data handled by some other consuming code.

Integrations are like reference assemblies that your Workflow consumes.  Each integration offers a variety of actions which generally map directly to an API endpoint within that integration’s Web API.  Integrations are defined within your Rewst account and are then available to every Workflow you design.

Actions (also called Tasks) are like the functions exposed by a reference assembly.  In many ways you can think of the action like a managed wrapper for a Win32 function.  The action provides you with input fields specific to the action and outputs an object that contains the result of the related API call while abstracting the actual underlying HTTP method and JSON data.  This makes each action feel more like an individual function call as opposed to a full routine that needs to handle boilerplate HTTP transmission code in addition to whatever code is necessary for the API call itself.  Actions link to other actions through Transitions.
### Transitions
Transitions define the path through which execution flows from one Action to the next within a workflow (referred to as ‘following the transition’).  An action can have multiple transitions and each transition has criteria that defines whether or not that particular transition is taken (followed) to the next action.  These criteria include “if the task succeeds”, “if the task fails”, “always” and a custom code expression.  We’ll cover more on transition criteria later, but initially you will likely just be using the succeed and/or fail criteria for most actions.

Each transition can link to one or more child actions and each linked action will execute in parallel, assuming the action’s transition criteria are met.  By default, every transition parented to an action must be complete before the child action will execute; however, this can be adjusted in the advanced options of the action.  Also, by default, an action will follow all of the transitions whose criteria are satisfied; however, an action may be configured to follow only the first transition with matching criteria.  Again, we will cover more on this in subsequent articles, but initially most of your actions will likely be configured to follow all transitions.

While transitions have a few other advanced settings that we will save for other articles, one that we need to cover as it is often used, is the “with items” option.  Specifying a value for With-Items causes the action to repeat once for each item in the With-Items list.  This is essentially how you loop over an action. 

While the action itself is capable of adding its output directly to the current context, each transition can also add its own customized output to the context.  Typically, you will use one or the other (either the action publishes a result, or the transition(s) do) but there may be cases where you use both options.

In order for us to discuss how actions add output to the context and how looping over an action works, we first have to talk about Jinja.
### Introduction to Jinja
Jinja is a templating engine typically implemented as middleware to provide another system with rich text templating.  In other words, it is a very fancy string formatting library.  As a middleware solution, the exact behavior of Jinja code can depend on the implementation.  While much of what you may find online in terms of general Jinja use (e.g. Stackoverflow search results) is applicable in Rewst, there may be minor modifications necessary to accommodate Rewst’s implementation.  More on this later, but the most important thing may be knowing about the “do” keyword – calling any method on a Jinja object requires using the do keyword (e.g.:  do someArray.append(aValue)).

You can think of Jinja as a combination of String.Format/strf/printf methods combined with lambdas.  You still write strings with text-replacement placeholders that point into an array of provided values, however, the “array of provided values” isn’t directly provided in your code and is instead made up of all of the data available in the current context as well as other Jinja functions.  So, when thinking of how formatting a string replaces a text placeholder with a value, bear in mind that those “values” can be anything from literals to variables to other blocks of code.  So again, it is much akin to passing lambdas into a string format method.

